import streamlit as st
import chromadb
from chromadb.utils import embedding_functions
from dotenv import load_dotenv
import requests
from bs4 import BeautifulSoup
import re
import os
import openai
import time

# Konfiguracja strony
st.set_page_config(
    page_title="ğŸ‡«ğŸ‡· RAG Wikipedia - Francja",
    page_icon="ğŸ‡«ğŸ‡·",
    layout="wide",
    initial_sidebar_state="expanded"
)

load_dotenv()


class WikipediaRAG:
    def __init__(self, db_path="./chroma_db", collection_name="francja_wikipedia"):
        self.db_path = db_path
        self.collection_name = collection_name
        self.client = None
        self.collection = None
        self.embedding_fn = None

    def initialize(self):
        """Inicjalizuje poÅ‚Ä…czenie z bazÄ… danych"""
        try:
            # Sprawdzamy klucz OpenAI
            if not os.getenv("OPENAI_API_KEY"):
                return False, "Brak klucza OpenAI API. Ustaw OPENAI_API_KEY w pliku .env"

            openai.api_key = os.getenv("OPENAI_API_KEY")

            # Inicjalizacja ChromaDB
            self.client = chromadb.PersistentClient(path=self.db_path)
            self.embedding_fn = embedding_functions.OpenAIEmbeddingFunction(
                api_key=os.getenv("OPENAI_API_KEY"),
                model_name="text-embedding-3-small"
            )

            # Sprawdzamy czy kolekcja istnieje
            try:
                self.collection = self.client.get_collection(
                    name=self.collection_name,
                    embedding_function=self.embedding_fn
                )
                return True, f"ZaÅ‚adowano kolekcjÄ™ z {self.collection.count()} dokumentÃ³w"
            except:
                return True, "Kolekcja nie istnieje - bÄ™dzie utworzona"

        except Exception as e:
            return False, f"BÅ‚Ä…d inicjalizacji: {str(e)}"

    def scrape_wikipedia_article(self, url):
        """Pobiera treÅ›Ä‡ artykuÅ‚u z Wikipedii"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }

            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()

            soup = BeautifulSoup(response.content, 'html.parser')

            # PrÃ³bujemy rÃ³Å¼ne selektory
            content_selectors = [
                'div#mw-content-text',
                'div.mw-parser-output',
                'div#bodyContent'
            ]

            content_div = None
            for selector in content_selectors:
                content_div = soup.select_one(selector)
                if content_div:
                    break

            if not content_div:
                content_div = soup

            # Czyszczenie
            for selector in ['.navbox', '.infobox', '.toc', '.references']:
                for element in content_div.select(selector):
                    element.decompose()

            for table in content_div.find_all('table'):
                table.decompose()

            paragraphs = content_div.find_all('p')

            cleaned_paragraphs = []
            for p in paragraphs:
                text = p.get_text()
                text = re.sub(r'\s+', ' ', text).strip()
                text = re.sub(r'\[[0-9]+\]', '', text)

                if len(text) > 50:
                    cleaned_paragraphs.append(text)

            return cleaned_paragraphs

        except Exception as e:
            st.error(f"BÅ‚Ä…d pobierania z Wikipedii: {e}")
            return self.get_fallback_data()

    def get_fallback_data(self):
        """Dane zapasowe o Francji"""
        return [
            "Francja, oficjalnie Republika Francuska â€“ paÅ„stwo, ktÃ³rego terytorium metropolitalne znajduje siÄ™ w Europie Zachodniej, oraz ktÃ³re posiada terytoria zamorskie na innych kontynentach.",
            "StolicÄ… Francji jest ParyÅ¼, a jÄ™zyk urzÄ™dowy to francuski. Francja jest republikÄ… unitarnÄ… o ustroju pÃ³Å‚prezydenckim.",
            "Francja graniczy z BelgiÄ…, Luksemburgiem, Niemcami, SzwajcariÄ…, WÅ‚ochami, Monako, AndorÄ… oraz HiszpaniÄ….",
            "Pod wzglÄ™dem liczby ludnoÅ›ci Francja jest drugim najwiÄ™kszym krajem Unii Europejskiej po Niemczech. Liczba mieszkaÅ„cÃ³w wynosi okoÅ‚o 68 milionÃ³w.",
            "NajwiÄ™ksze miasta to ParyÅ¼, Marsylia, Lyon, Tuluza, Nicea, Nantes, Strasburg, Montpellier, Bordeaux i Lille.",
            "Francja jest czÅ‚onkiem zaÅ‚oÅ¼ycielem Unii Europejskiej i jednym z paÅ„stw czÅ‚onkowskich Strefy Schengen.",
            "Gospodarka Francji jest jednÄ… z najwiÄ™kszych na Å›wiecie. Specjalizuje siÄ™ w przemyÅ›le lotniczym, motoryzacyjnym i turystyce.",
            "Historia Francji siÄ™ga czasÃ³w staroÅ¼ytnych. Kraj przeszedÅ‚ przez rewolucjÄ™ francuskÄ… w 1789 roku i okres Napoleona Bonaparte."
        ]

    def chunk_text(self, text, max_length=500, overlap=50):
        """Dzieli tekst na chunki"""
        if len(text) <= max_length:
            return [text]

        sentences = re.split(r'[.!?]+', text)
        chunks = []
        current_chunk = ""

        for sentence in sentences:
            sentence = sentence.strip()
            if not sentence:
                continue

            if len(current_chunk + sentence) <= max_length:
                current_chunk += sentence + ". "
            else:
                if current_chunk:
                    chunks.append(current_chunk.strip())
                current_chunk = sentence + ". "

        if current_chunk:
            chunks.append(current_chunk.strip())

        return chunks

    def load_wikipedia_data(self, url="https://pl.wikipedia.org/wiki/Francja", progress_callback=None):
        """Åaduje dane z Wikipedii"""
        try:
            if progress_callback:
                progress_callback(0.1, "Pobieranie danych z Wikipedii...")

            paragraphs = self.scrape_wikipedia_article(url)

            if not paragraphs:
                return False, "Nie udaÅ‚o siÄ™ pobraÄ‡ danych"

            if progress_callback:
                progress_callback(0.3, f"Przetwarzanie {len(paragraphs)} paragrafÃ³w...")

            # Chunking
            all_chunks = []
            for paragraph in paragraphs:
                chunks = self.chunk_text(paragraph, max_length=600, overlap=100)
                all_chunks.extend(chunks)

            if progress_callback:
                progress_callback(0.5, f"Tworzenie kolekcji z {len(all_chunks)} chunkÃ³w...")

            # Usuwamy starÄ… kolekcjÄ™
            try:
                self.client.delete_collection(self.collection_name)
            except:
                pass

            # Tworzymy nowÄ…
            self.collection = self.client.create_collection(
                name=self.collection_name,
                embedding_function=self.embedding_fn
            )

            # Przygotowujemy dane
            documents = all_chunks
            ids = [f"chunk_{i}" for i in range(len(all_chunks))]
            metadatas = [{"source": "wikipedia_francja", "chunk_id": i} for i in range(len(all_chunks))]

            if progress_callback:
                progress_callback(0.7, "Dodawanie do bazy wektorowej...")

            # Dodajemy w batches
            batch_size = 50
            for i in range(0, len(documents), batch_size):
                batch_docs = documents[i:i + batch_size]
                batch_ids = ids[i:i + batch_size]
                batch_metas = metadatas[i:i + batch_size]

                self.collection.add(
                    documents=batch_docs,
                    ids=batch_ids,
                    metadatas=batch_metas
                )

                if progress_callback:
                    progress = 0.7 + (0.2 * (i + batch_size) / len(documents))
                    progress_callback(progress,
                                      f"Przetworzono {min(i + batch_size, len(documents))}/{len(documents)} dokumentÃ³w")

            if progress_callback:
                progress_callback(1.0, f"Gotowe! ZaÅ‚adowano {len(documents)} dokumentÃ³w")

            return True, f"PomyÅ›lnie zaÅ‚adowano {len(documents)} dokumentÃ³w"

        except Exception as e:
            return False, f"BÅ‚Ä…d Å‚adowania danych: {str(e)}"

    def retrieve_relevant_chunks(self, query, n_results=5):
        """Wyszukuje relevantne chunki"""
        if not self.collection:
            return []

        try:
            results = self.collection.query(
                query_texts=[query],
                n_results=n_results
            )
            return results['documents'][0] if results['documents'] else []
        except Exception as e:
            st.error(f"BÅ‚Ä…d wyszukiwania: {e}")
            return []

    def generate_answer(self, query, context_chunks):
        """Generuje odpowiedÅº uÅ¼ywajÄ…c GPT"""
        if not context_chunks:
            return "Nie znaleziono relevantnych informacji w bazie wiedzy."

        context = "\n\n".join(context_chunks)

        system_prompt = """JesteÅ› asystentem AI odpowiadajÄ…cym na pytania o FrancjÄ™ na podstawie fragmentÃ³w z Wikipedii.

INSTRUKCJE:
1. Odpowiadaj TYLKO na podstawie dostarczonych fragmentÃ³w
2. JeÅ›li nie ma informacji w kontekÅ›cie, powiedz Å¼e nie masz takich danych
3. Odpowiadaj po polsku, precyzyjnie i konkretnie
4. Podawaj liczby i fakty z kontekstu gdy to moÅ¼liwe
5. BÄ…dÅº pomocny i przyjazny"""

        user_prompt = f"""KONTEKST:
{context}

PYTANIE: {query}

ODPOWIEDÅ¹:"""

        try:
            response = openai.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                max_tokens=500,
                temperature=0.3
            )

            return response.choices[0].message.content.strip()

        except Exception as e:
            return f"BÅ‚Ä…d generowania odpowiedzi: {e}"

    def ask(self, question):
        """GÅ‚Ã³wna funkcja RAG"""
        relevant_chunks = self.retrieve_relevant_chunks(question, n_results=5)

        if not relevant_chunks:
            return "Nie znaleziono relevantnych informacji.", []

        answer = self.generate_answer(question, relevant_chunks)
        return answer, relevant_chunks


# Inicjalizacja session state
if 'rag' not in st.session_state:
    st.session_state.rag = WikipediaRAG()
    st.session_state.initialized = False
    st.session_state.chat_history = []


def main():
    st.title("ğŸ‡«ğŸ‡· RAG Wikipedia - Francja")
    st.markdown("*System pytaÅ„ i odpowiedzi oparty na danych z Wikipedii*")

    # Sidebar - konfiguracja
    with st.sidebar:
        st.header("âš™ï¸ Konfiguracja")

        # Status inicjalizacji
        if not st.session_state.initialized:
            st.warning("ğŸ”„ System nie zostaÅ‚ zainicjalizowany")

            if st.button("ğŸš€ Inicjalizuj system", type="primary"):
                with st.spinner("Inicjalizacja..."):
                    success, message = st.session_state.rag.initialize()
                    if success:
                        st.session_state.initialized = True
                        st.success(f"âœ… {message}")
                        st.rerun()
                    else:
                        st.error(f"âŒ {message}")
        else:
            st.success("âœ… System zainicjalizowany")

            # Informacje o bazie
            if st.session_state.rag.collection:
                count = st.session_state.rag.collection.count()
                st.info(f"ğŸ“Š DokumentÃ³w w bazie: {count}")

                if count == 0:
                    st.warning("Baza jest pusta - zaÅ‚aduj dane z Wikipedii")

            # Åadowanie danych
            st.header("ğŸ“¥ Dane")

            wikipedia_url = st.text_input(
                "URL Wikipedii:",
                "https://pl.wikipedia.org/wiki/Francja"
            )

            if st.button("ğŸ”„ ZaÅ‚aduj/OdÅ›wieÅ¼ dane"):
                progress_bar = st.progress(0)
                status_text = st.empty()

                def progress_callback(progress, message):
                    progress_bar.progress(progress)
                    status_text.text(message)

                success, message = st.session_state.rag.load_wikipedia_data(
                    wikipedia_url,
                    progress_callback
                )

                if success:
                    st.success(f"âœ… {message}")
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error(f"âŒ {message}")

        # WyczyÅ›Ä‡ historiÄ™
        if st.button("ğŸ—‘ï¸ WyczyÅ›Ä‡ historiÄ™"):
            st.session_state.chat_history = []
            st.rerun()

    # GÅ‚Ã³wny interfejs
    if not st.session_state.initialized:
        st.info("ğŸ‘ˆ Rozpocznij od inicjalizacji systemu w bocznym panelu")
        return

    if not st.session_state.rag.collection or st.session_state.rag.collection.count() == 0:
        st.warning("ğŸ“¥ ZaÅ‚aduj najpierw dane z Wikipedii uÅ¼ywajÄ…c bocznego panelu")
        return

    # Chat interface
    st.header("ğŸ’¬ Zadaj pytanie o FrancjÄ™")

    # PrzykÅ‚adowe pytania
    st.subheader("ğŸ’¡ PrzykÅ‚adowe pytania:")
    example_questions = [
        "Jaka jest stolica Francji?",
        "Ile mieszkaÅ„cÃ³w ma Francja?",
        "Jakie sÄ… najwiÄ™ksze miasta Francji?",
        "Z jakimi krajami graniczy Francja?",
        "Jaki jest system polityczny Francji?",
        "Opowiedz o gospodarce Francji"
    ]

    cols = st.columns(2)
    for i, question in enumerate(example_questions):
        col = cols[i % 2]
        if col.button(f"â“ {question}", key=f"example_{i}"):
            st.session_state.current_question = question

    # Input dla pytania
    user_question = st.text_input(
        "Twoje pytanie:",
        value=st.session_state.get('current_question', ''),
        placeholder="Wpisz swoje pytanie o FrancjÄ™..."
    )

    if st.button("ğŸ” Zadaj pytanie", type="primary") and user_question:
        with st.spinner("Szukam odpowiedzi..."):
            answer, sources = st.session_state.rag.ask(user_question)

            # Dodaj do historii
            st.session_state.chat_history.append({
                'question': user_question,
                'answer': answer,
                'sources': sources
            })

            # WyczyÅ›Ä‡ current_question
            if 'current_question' in st.session_state:
                del st.session_state.current_question

            st.rerun()

    # Historia czatu
    if st.session_state.chat_history:
        st.header("ğŸ“ Historia rozmowy")

        for i, chat in enumerate(reversed(st.session_state.chat_history)):
            with st.expander(f"â“ {chat['question']}", expanded=(i == 0)):
                st.markdown(f"**OdpowiedÅº:** {chat['answer']}")

                if chat['sources']:
                    st.markdown("**Å¹rÃ³dÅ‚a:**")
                    for j, source in enumerate(chat['sources'][:3]):
                        with st.container():
                            st.caption(f"Å¹rÃ³dÅ‚o {j + 1}:")
                            st.text(source[:200] + "..." if len(source) > 200 else source)


if __name__ == "__main__":
    main()
